{
  "version": 3,
  "sources": ["../../music-metadata/lib/flac/FlacParser.js", "../../music-metadata/lib/ogg/vorbis/Vorbis.js", "../../music-metadata/lib/ogg/vorbis/VorbisStream.js", "../../music-metadata/lib/ogg/vorbis/VorbisDecoder.js", "../../music-metadata/lib/flac/FlacToken.js"],
  "sourcesContent": ["import initDebug from 'debug';\nimport { Uint8ArrayType } from 'token-types';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as Flac from './FlacToken.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case Flac.BlockType.STREAMINFO:\n                return this.readBlockStreamInfo(blockHeader.length);\n            case Flac.BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case Flac.BlockType.APPLICATION:\n                break;\n            case Flac.BlockType.SEEKTABLE:\n                break;\n            case Flac.BlockType.VORBIS_COMMENT:\n                return this.readComment(blockHeader.length);\n            case Flac.BlockType.CUESHEET:\n                break;\n            case Flac.BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async readBlockStreamInfo(dataLen) {\n        if (dataLen !== Flac.BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.processsStreamInfo(streamInfo);\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    processsStreamInfo(streamInfo) {\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('hasAudio', true);\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Read VORBIS_COMMENT from tokenizer\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async readComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        return this.parseComment(data);\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(data) {\n        const decoder = new VorbisDecoder(data, 0);\n        const vendor = decoder.readStringUtf8();\n        if (vendor.length > 0) {\n            this.metadata.setFormat('tool', vendor);\n        }\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => {\n            if (tag.key === 'ENCODER') {\n                this.metadata.setFormat('tool', tag.value);\n            }\n            return this.addTag(tag.key, tag.value);\n        }));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\n    }\n    addPictureTag(picture) {\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n    addTag(id, value) {\n        return this.vorbisParser.addTag(id, value);\n    }\n}\n", "import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = buffer.slice(offset, offset + picDataLen);\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n", "import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggStream\n */\nexport class VorbisStream {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.durationOnLastPage = true;\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        this.lastPageHeader = header;\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration() {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param _header\n     * @param pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        this.metadata.setFormat('hasAudio', true);\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n", "import * as Token from 'token-types';\nimport { textDecode } from '@borewit/text-codec';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = textDecode(this.data.subarray(this.offset, this.offset + len), 'utf-8');\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.substring(0, idx).toUpperCase(),\n            value: v.substring(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n", "import * as util from '../common/Util.js';\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nexport const BlockType = {\n    STREAMINFO: 0, // STREAMINFO\n    PADDING: 1, // PADDING\n    APPLICATION: 2, // APPLICATION\n    SEEKTABLE: 3, // SEEKTABLE\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\n    CUESHEET: 5, // CUESHEET\n    PICTURE: 6 // PICTURE\n};\nexport const BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nexport const BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n"],
  "mappings": "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",
  "names": ["import_debug", "debugInit", "debug", "initDebug"]
}

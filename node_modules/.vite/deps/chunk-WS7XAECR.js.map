{
  "version": 3,
  "sources": ["../../uint8array-extras/index.js", "../../music-metadata/lib/common/Util.js"],
  "sourcesContent": ["const objectToString = Object.prototype.toString;\nconst uint8ArrayStringified = '[object Uint8Array]';\nconst arrayBufferStringified = '[object ArrayBuffer]';\n\nfunction isType(value, typeConstructor, typeStringified) {\n\tif (!value) {\n\t\treturn false;\n\t}\n\n\tif (value.constructor === typeConstructor) {\n\t\treturn true;\n\t}\n\n\treturn objectToString.call(value) === typeStringified;\n}\n\nexport function isUint8Array(value) {\n\treturn isType(value, Uint8Array, uint8ArrayStringified);\n}\n\nfunction isArrayBuffer(value) {\n\treturn isType(value, ArrayBuffer, arrayBufferStringified);\n}\n\nfunction isUint8ArrayOrArrayBuffer(value) {\n\treturn isUint8Array(value) || isArrayBuffer(value);\n}\n\nexport function assertUint8Array(value) {\n\tif (!isUint8Array(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nexport function assertUint8ArrayOrArrayBuffer(value) {\n\tif (!isUint8ArrayOrArrayBuffer(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\` or \\`ArrayBuffer\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nexport function toUint8Array(value) {\n\tif (value instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(value);\n\t}\n\n\tif (ArrayBuffer.isView(value)) {\n\t\treturn new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\n\t}\n\n\tthrow new TypeError(`Unsupported value, got \\`${typeof value}\\`.`);\n}\n\nexport function concatUint8Arrays(arrays, totalLength) {\n\tif (arrays.length === 0) {\n\t\treturn new Uint8Array(0);\n\t}\n\n\ttotalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);\n\n\tconst returnValue = new Uint8Array(totalLength);\n\n\tlet offset = 0;\n\tfor (const array of arrays) {\n\t\tassertUint8Array(array);\n\t\treturnValue.set(array, offset);\n\t\toffset += array.length;\n\t}\n\n\treturn returnValue;\n}\n\nexport function areUint8ArraysEqual(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\t// eslint-disable-next-line unicorn/no-for-loop\n\tfor (let index = 0; index < a.length; index++) {\n\t\tif (a[index] !== b[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function compareUint8Arrays(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tconst length = Math.min(a.length, b.length);\n\n\tfor (let index = 0; index < length; index++) {\n\t\tconst diff = a[index] - b[index];\n\t\tif (diff !== 0) {\n\t\t\treturn Math.sign(diff);\n\t\t}\n\t}\n\n\t// At this point, all the compared elements are equal.\n\t// The shorter array should come first if the arrays are of different lengths.\n\treturn Math.sign(a.length - b.length);\n}\n\nconst cachedDecoders = {\n\tutf8: new globalThis.TextDecoder('utf8'),\n};\n\nexport function uint8ArrayToString(array, encoding = 'utf8') {\n\tassertUint8ArrayOrArrayBuffer(array);\n\tcachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);\n\treturn cachedDecoders[encoding].decode(array);\n}\n\nfunction assertString(value) {\n\tif (typeof value !== 'string') {\n\t\tthrow new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nexport function stringToUint8Array(string) {\n\tassertString(string);\n\treturn cachedEncoder.encode(string);\n}\n\nfunction base64ToBase64Url(base64) {\n\treturn base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');\n}\n\nfunction base64UrlToBase64(base64url) {\n\tconst base64 = base64url.replaceAll('-', '+').replaceAll('_', '/');\n\tconst padding = (4 - (base64.length % 4)) % 4;\n\treturn base64 + '='.repeat(padding);\n}\n\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\n// Important: Keep this value divisible by 3 so intermediate chunks produce no Base64 padding.\nconst MAX_BLOCK_SIZE = 65_535;\n\nexport function uint8ArrayToBase64(array, {urlSafe = false} = {}) {\n\tassertUint8Array(array);\n\n\tlet base64 = '';\n\n\tfor (let index = 0; index < array.length; index += MAX_BLOCK_SIZE) {\n\t\tconst chunk = array.subarray(index, index + MAX_BLOCK_SIZE);\n\t\t// Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n\t\tbase64 += globalThis.btoa(String.fromCodePoint.apply(undefined, chunk));\n\t}\n\n\treturn urlSafe ? base64ToBase64Url(base64) : base64;\n}\n\nexport function base64ToUint8Array(base64String) {\n\tassertString(base64String);\n\treturn Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), x => x.codePointAt(0));\n}\n\nexport function stringToBase64(string, {urlSafe = false} = {}) {\n\tassertString(string);\n\treturn uint8ArrayToBase64(stringToUint8Array(string), {urlSafe});\n}\n\nexport function base64ToString(base64String) {\n\tassertString(base64String);\n\treturn uint8ArrayToString(base64ToUint8Array(base64String));\n}\n\nconst byteToHexLookupTable = Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));\n\nexport function uint8ArrayToHex(array) {\n\tassertUint8Array(array);\n\n\t// Concatenating a string is faster than using an array.\n\tlet hexString = '';\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.\n\tfor (let index = 0; index < array.length; index++) {\n\t\thexString += byteToHexLookupTable[array[index]];\n\t}\n\n\treturn hexString;\n}\n\nconst hexToDecimalLookupTable = {\n\t0: 0,\n\t1: 1,\n\t2: 2,\n\t3: 3,\n\t4: 4,\n\t5: 5,\n\t6: 6,\n\t7: 7,\n\t8: 8,\n\t9: 9,\n\ta: 10,\n\tb: 11,\n\tc: 12,\n\td: 13,\n\te: 14,\n\tf: 15,\n\tA: 10,\n\tB: 11,\n\tC: 12,\n\tD: 13,\n\tE: 14,\n\tF: 15,\n};\n\nexport function hexToUint8Array(hexString) {\n\tassertString(hexString);\n\n\tif (hexString.length % 2 !== 0) {\n\t\tthrow new Error('Invalid Hex string length.');\n\t}\n\n\tconst resultLength = hexString.length / 2;\n\tconst bytes = new Uint8Array(resultLength);\n\n\tfor (let index = 0; index < resultLength; index++) {\n\t\tconst highNibble = hexToDecimalLookupTable[hexString[index * 2]];\n\t\tconst lowNibble = hexToDecimalLookupTable[hexString[(index * 2) + 1]];\n\n\t\tif (highNibble === undefined || lowNibble === undefined) {\n\t\t\tthrow new Error(`Invalid Hex character encountered at position ${index * 2}`);\n\t\t}\n\n\t\tbytes[index] = (highNibble << 4) | lowNibble; // eslint-disable-line no-bitwise\n\t}\n\n\treturn bytes;\n}\n\n/**\n@param {DataView} view\n@returns {number}\n*/\nexport function getUintBE(view) {\n\tconst {byteLength} = view;\n\n\tif (byteLength === 6) {\n\t\treturn (view.getUint16(0) * (2 ** 32)) + view.getUint32(2);\n\t}\n\n\tif (byteLength === 5) {\n\t\treturn (view.getUint8(0) * (2 ** 32)) + view.getUint32(1);\n\t}\n\n\tif (byteLength === 4) {\n\t\treturn view.getUint32(0);\n\t}\n\n\tif (byteLength === 3) {\n\t\treturn (view.getUint8(0) * (2 ** 16)) + view.getUint16(1);\n\t}\n\n\tif (byteLength === 2) {\n\t\treturn view.getUint16(0);\n\t}\n\n\tif (byteLength === 1) {\n\t\treturn view.getUint8(0);\n\t}\n}\n\n/**\n@param {Uint8Array} array\n@param {Uint8Array} value\n@returns {number}\n*/\nexport function indexOf(array, value) {\n\tconst arrayLength = array.length;\n\tconst valueLength = value.length;\n\n\tif (valueLength === 0) {\n\t\treturn -1;\n\t}\n\n\tif (valueLength > arrayLength) {\n\t\treturn -1;\n\t}\n\n\tconst validOffsetLength = arrayLength - valueLength;\n\n\tfor (let index = 0; index <= validOffsetLength; index++) {\n\t\tlet isMatch = true;\n\t\tfor (let index2 = 0; index2 < valueLength; index2++) {\n\t\t\tif (array[index + index2] !== value[index2]) {\n\t\t\t\tisMatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (isMatch) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n@param {Uint8Array} array\n@param {Uint8Array} value\n@returns {boolean}\n*/\nexport function includes(array, value) {\n\treturn indexOf(array, value) !== -1;\n}\n", "import { StringType } from 'token-types';\nimport { FieldDecodingError } from '../ParseError.js';\nimport { getUintBE } from 'uint8array-extras';\nexport function getBit(buf, off, bit) {\n    return (buf[off] & (1 << bit)) !== 0;\n}\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nexport function findZero(uint8Array, start, end, encoding) {\n    let i = start;\n    if (encoding === 'utf-16le') {\n        while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n            if (i >= end)\n                return end;\n            i += 2;\n        }\n        return i;\n    }\n    while (uint8Array[i] !== 0) {\n        if (i >= end)\n            return end;\n        i++;\n    }\n    return i;\n}\nexport function trimRightNull(x) {\n    const pos0 = x.indexOf('\\0');\n    return pos0 === -1 ? x : x.substr(0, pos0);\n}\nfunction swapBytes(uint8Array) {\n    const l = uint8Array.length;\n    if ((l & 1) !== 0)\n        throw new FieldDecodingError('Buffer length must be even');\n    for (let i = 0; i < l; i += 2) {\n        const a = uint8Array[i];\n        uint8Array[i] = uint8Array[i + 1];\n        uint8Array[i + 1] = a;\n    }\n    return uint8Array;\n}\n/**\n * Decode string\n */\nexport function decodeString(uint8Array, encoding) {\n    // annoying workaround for a double BOM issue\n    // https://github.com/leetreveil/musicmetadata/issues/84\n    if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) { // little endian\n        return decodeString(uint8Array.subarray(2), encoding);\n    }\n    if (encoding === 'utf-16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n        // BOM, indicating big endian decoding\n        if ((uint8Array.length & 1) !== 0)\n            throw new FieldDecodingError('Expected even number of octets for 16-bit unicode string');\n        return decodeString(swapBytes(uint8Array), encoding);\n    }\n    return new StringType(uint8Array.length, encoding).get(uint8Array, 0);\n}\nexport function stripNulls(str) {\n    str = str.replace(/^\\x00+/g, '');\n    str = str.replace(/\\x00+$/g, '');\n    return str;\n}\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nexport function getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n    const byteOff = byteOffset + ~~(bitOffset / 8);\n    const bitOff = bitOffset % 8;\n    let value = source[byteOff];\n    value &= 0xff >> bitOff;\n    const bitsRead = 8 - bitOff;\n    const bitsLeft = len - bitsRead;\n    if (bitsLeft < 0) {\n        value >>= (8 - bitOff - len);\n    }\n    else if (bitsLeft > 0) {\n        value <<= bitsLeft;\n        value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n    }\n    return value;\n}\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nexport function isBitSet(source, byteOffset, bitOffset) {\n    return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexport function a2hex(str) {\n    const arr = [];\n    for (let i = 0, l = str.length; i < l; i++) {\n        const hex = Number(str.charCodeAt(i)).toString(16);\n        arr.push(hex.length === 1 ? `0${hex}` : hex);\n    }\n    return arr.join(' ');\n}\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nexport function ratioToDb(ratio) {\n    return 10 * Math.log10(ratio);\n}\n/**\n * Convert dB to ratio\n * db Decibels\n */\nexport function dbToRatio(dB) {\n    return 10 ** (dB / 10);\n}\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nexport function toRatio(value) {\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\n    if (ps.length >= 1) {\n        const v = Number.parseFloat(ps[0]);\n        return ps.length === 2 && ps[1] === 'db' ? {\n            dB: v,\n            ratio: dbToRatio(v)\n        } : {\n            dB: ratioToDb(v),\n            ratio: v\n        };\n    }\n}\n/**\n * Decode a big-endian unsigned integer from a Uint8Array.\n * Supports dynamic length (1â€“8 bytes).\n */\nexport function decodeUintBE(uint8Array) {\n    if (uint8Array.length === 0) {\n        throw new Error(\"decodeUintBE: empty Uint8Array\");\n    }\n    const view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    return getUintBE(view);\n}\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../music-metadata/lib/apev2/APEv2Parser.js", "../../@borewit/text-codec/lib/index.js", "../../music-metadata/lib/common/FourCC.js", "../../music-metadata/lib/apev2/APEv2Token.js"],
  "sourcesContent": ["import initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { StringType } from 'token-types';\nimport * as util from '../common/Util.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { DataType, DescriptorParser, Header, TagFooter, TagItemHeader } from './APEv2Token.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { textDecode } from '@borewit/text-codec';\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nexport class ApeContentError extends makeUnexpectedFileContentError('APEv2') {\n}\nexport function tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n}\nexport class APEv2Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param tokenizer\n     * @param offset\n     */\n    static async findApeFooterOffset(tokenizer, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = new Uint8Array(TagFooter.len);\n        const position = tokenizer.position;\n        if (offset <= TagFooter.len) {\n            debug(`Offset is too small to read APE footer: offset=${offset}`);\n            return undefined;\n        }\n        if (offset > TagFooter.len) {\n            await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });\n            tokenizer.setPosition(position);\n            const tagFooter = TagFooter.get(apeBuf, 0);\n            if (tagFooter.ID === 'APETAGEX') {\n                if (tagFooter.flags.isHeader) {\n                    debug(`APE Header found at offset=${offset - TagFooter.len}`);\n                }\n                else {\n                    debug(`APE Footer found at offset=${offset - TagFooter.len}`);\n                    offset -= tagFooter.size;\n                }\n                return { footer: tagFooter, offset };\n            }\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = TagFooter.get(buffer, buffer.length - TagFooter.len);\n        if (footer.ID !== preamble)\n            throw new ApeContentError('Unexpected APEv2 Footer ID preamble value');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {\n            debug(\"No APEv2 header found, end-of-file reached\");\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(TagFooter.len);\n            return this.parseTags(footer);\n        }\n        debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n        if (this.tokenizer.fileInfo.size) {\n            // Try to read the APEv2 header using just the footer-header\n            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n            const buffer = new Uint8Array(remaining);\n            await this.tokenizer.readBuffer(buffer);\n            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(DescriptorParser);\n        if (descriptor.ID !== 'MAC ')\n            throw new ApeContentError('Unexpected descriptor ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        this.metadata.setAudioOnly();\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = new Uint8Array(256); // maximum tag key length\n        let bytesRemaining = footer.size - TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);\n            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case DataType.text_utf8: { // utf-8 text-string\n                    const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    await Promise.all(values.map(val => this.metadata.addTag(tagFormat, key, val)));\n                    break;\n                }\n                case DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = new Uint8Array(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = util.findZero(picData, 0, picData.length);\n                        const description = textDecode(picData.subarray(0, zero), 'utf-8');\n                        const data = picData.subarray(zero + 1);\n                        await this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                case DataType.reserved:\n                    debug(`Ignore external info ${key}`);\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        if (!this.ape.descriptor) {\n            throw new ApeContentError('Missing APE descriptor');\n        }\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\n", "const WINDOWS_1252_EXTRA = {\n    0x80: \"€\", 0x82: \"‚\", 0x83: \"ƒ\", 0x84: \"„\", 0x85: \"…\", 0x86: \"†\",\n    0x87: \"‡\", 0x88: \"ˆ\", 0x89: \"‰\", 0x8a: \"Š\", 0x8b: \"‹\", 0x8c: \"Œ\",\n    0x8e: \"Ž\", 0x91: \"‘\", 0x92: \"’\", 0x93: \"“\", 0x94: \"”\", 0x95: \"•\",\n    0x96: \"–\", 0x97: \"—\", 0x98: \"˜\", 0x99: \"™\", 0x9a: \"š\", 0x9b: \"›\",\n    0x9c: \"œ\", 0x9e: \"ž\", 0x9f: \"Ÿ\",\n};\nconst WINDOWS_1252_REVERSE = {};\nfor (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {\n    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);\n}\n/**\n * Decode text from binary data\n * @param bytes Binary data\n * @param encoding Encoding\n */\nexport function textDecode(bytes, encoding = \"utf-8\") {\n    switch (encoding.toLowerCase()) {\n        case \"utf-8\":\n        case \"utf8\":\n            if (typeof globalThis.TextDecoder !== \"undefined\") {\n                return new globalThis.TextDecoder(\"utf-8\").decode(bytes);\n            }\n            return decodeUTF8(bytes);\n        case \"utf-16le\":\n            return decodeUTF16LE(bytes);\n        case \"ascii\":\n            return decodeASCII(bytes);\n        case \"latin1\":\n        case \"iso-8859-1\":\n            return decodeLatin1(bytes);\n        case \"windows-1252\":\n            return decodeWindows1252(bytes);\n        default:\n            throw new RangeError(`Encoding '${encoding}' not supported`);\n    }\n}\nexport function textEncode(input = \"\", encoding = \"utf-8\") {\n    switch (encoding.toLowerCase()) {\n        case \"utf-8\":\n        case \"utf8\":\n            if (typeof globalThis.TextEncoder !== \"undefined\") {\n                return new globalThis.TextEncoder().encode(input);\n            }\n            return encodeUTF8(input);\n        case \"utf-16le\":\n            return encodeUTF16LE(input);\n        case \"ascii\":\n            return encodeASCII(input);\n        case \"latin1\":\n        case \"iso-8859-1\":\n            return encodeLatin1(input);\n        case \"windows-1252\":\n            return encodeWindows1252(input);\n        default:\n            throw new RangeError(`Encoding '${encoding}' not supported`);\n    }\n}\n// --- Internal helpers ---\nfunction decodeUTF8(bytes) {\n    let out = \"\";\n    let i = 0;\n    while (i < bytes.length) {\n        const b1 = bytes[i++];\n        if (b1 < 0x80) {\n            out += String.fromCharCode(b1);\n        }\n        else if (b1 < 0xe0) {\n            const b2 = bytes[i++] & 0x3f;\n            out += String.fromCharCode(((b1 & 0x1f) << 6) | b2);\n        }\n        else if (b1 < 0xf0) {\n            const b2 = bytes[i++] & 0x3f;\n            const b3 = bytes[i++] & 0x3f;\n            out += String.fromCharCode(((b1 & 0x0f) << 12) | (b2 << 6) | b3);\n        }\n        else {\n            const b2 = bytes[i++] & 0x3f;\n            const b3 = bytes[i++] & 0x3f;\n            const b4 = bytes[i++] & 0x3f;\n            let cp = ((b1 & 0x07) << 18) |\n                (b2 << 12) |\n                (b3 << 6) |\n                b4;\n            cp -= 0x10000;\n            out += String.fromCharCode(0xd800 + ((cp >> 10) & 0x3ff), 0xdc00 + (cp & 0x3ff));\n        }\n    }\n    return out;\n}\nfunction decodeUTF16LE(bytes) {\n    let out = \"\";\n    for (let i = 0; i < bytes.length; i += 2) {\n        out += String.fromCharCode(bytes[i] | (bytes[i + 1] << 8));\n    }\n    return out;\n}\nfunction decodeASCII(bytes) {\n    return String.fromCharCode(...bytes.map((b) => b & 0x7f));\n}\nfunction decodeLatin1(bytes) {\n    return String.fromCharCode(...bytes);\n}\nfunction decodeWindows1252(bytes) {\n    let out = \"\";\n    for (const b of bytes) {\n        if (b >= 0x80 && b <= 0x9f && WINDOWS_1252_EXTRA[b]) {\n            out += WINDOWS_1252_EXTRA[b];\n        }\n        else {\n            out += String.fromCharCode(b);\n        }\n    }\n    return out;\n}\nfunction encodeUTF8(str) {\n    const out = [];\n    for (let i = 0; i < str.length; i++) {\n        const cp = str.charCodeAt(i);\n        if (cp < 0x80) {\n            out.push(cp);\n        }\n        else if (cp < 0x800) {\n            out.push(0xc0 | (cp >> 6), 0x80 | (cp & 0x3f));\n        }\n        else if (cp < 0x10000) {\n            out.push(0xe0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3f), 0x80 | (cp & 0x3f));\n        }\n        else {\n            out.push(0xf0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3f), 0x80 | ((cp >> 6) & 0x3f), 0x80 | (cp & 0x3f));\n        }\n    }\n    return new Uint8Array(out);\n}\nfunction encodeUTF16LE(str) {\n    const out = new Uint8Array(str.length * 2);\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n        out[i * 2] = code & 0xff;\n        out[i * 2 + 1] = code >> 8;\n    }\n    return out;\n}\nfunction encodeASCII(str) {\n    return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 0x7f));\n}\nfunction encodeLatin1(str) {\n    return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 0xff));\n}\nfunction encodeWindows1252(str) {\n    return new Uint8Array([...str].map((ch) => {\n        const code = ch.charCodeAt(0);\n        if (code <= 0xff)\n            return code;\n        if (WINDOWS_1252_REVERSE[ch] !== undefined)\n            return WINDOWS_1252_REVERSE[ch];\n        return 0x3f; // '?'\n    }));\n}\n", "import { textDecode, textEncode } from '@borewit/text-codec';\nimport * as util from './Util.js';\nimport { InternalParserError, FieldDecodingError } from '../ParseError.js';\nconst validFourCC = /^[\\x21-\\x7e©][\\x20-\\x7e\\x00()]{3}/;\n/**\n * Token for read FourCC\n * Ref: https://en.wikipedia.org/wiki/FourCC\n */\nexport const FourCcToken = {\n    len: 4,\n    get: (buf, off) => {\n        const id = textDecode(buf.subarray(off, off + FourCcToken.len), 'latin1');\n        if (!id.match(validFourCC)) {\n            throw new FieldDecodingError(`FourCC contains invalid characters: ${util.a2hex(id)} \"${id}\"`);\n        }\n        return id;\n    },\n    put: (buffer, offset, id) => {\n        const str = textEncode(id, 'latin1');\n        if (str.length !== 4)\n            throw new InternalParserError('Invalid length');\n        buffer.set(str, offset);\n        return offset + 4;\n    }\n};\n", "import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\nexport const DataType = {\n    text_utf8: 0,\n    binary: 1,\n    external_info: 2,\n    reserved: 3\n};\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexport const DescriptorParser = {\n    len: 52,\n    get: (buf, off) => {\n        return {\n            // should equal 'MAC '\n            ID: FourCcToken.get(buf, off),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n            // the number of descriptor bytes (allows later expansion of this header)\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n            // the number of header APE_HEADER bytes\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\n            // the number of header APE_HEADER bytes\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n            // the number of header data bytes (from original file)\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n            // the number of bytes of APE frame data\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n            // the high order number of APE frame data bytes\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n            // the terminating data of the file (not including tag data)\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n            // the MD5 hash of the file (see notes for usage... it's a little tricky)\n            fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n        };\n    }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexport const Header = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n            compressionLevel: Token.UINT16_LE.get(buf, off),\n            // any format flags (for future use)\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\n            // the number of audio blocks in one frame\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n            // the number of audio blocks in the final frame\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n            // the total number of frames\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\n            // the bits per sample (typically 16)\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n            // the number of channels (1 or 2)\n            channel: Token.UINT16_LE.get(buf, off + 18),\n            // the sample rate (typically 44100)\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\n        };\n    }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexport const TagFooter = {\n    len: 32,\n    get: (buf, off) => {\n        return {\n            // should equal 'APETAGEX'\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\n            // equals CURRENT_APE_TAG_VERSION\n            version: Token.UINT32_LE.get(buf, off + 8),\n            // the complete size of the tag, including this footer (excludes header)\n            size: Token.UINT32_LE.get(buf, off + 12),\n            // the number of fields in the tag\n            fields: Token.UINT32_LE.get(buf, off + 16),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n        };\n    }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexport const TagItemHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Length of assigned value in bytes\n            size: Token.UINT32_LE.get(buf, off),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n        };\n    }\n};\nexport function parseTagFlags(flags) {\n    return {\n        containsHeader: isBitSet(flags, 31),\n        containsFooter: isBitSet(flags, 30),\n        isHeader: isBitSet(flags, 29),\n        readOnly: isBitSet(flags, 0),\n        dataType: (flags & 6) >> 1\n    };\n}\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nexport function isBitSet(num, bit) {\n    return (num & 1 << bit) !== 0;\n}\n"],
  "mappings": "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",
  "names": ["initDebug"]
}
